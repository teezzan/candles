// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"context"
	"github.com/teezzan/candles/internal/controller/ohlc/data"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			GetDataPointsFunc: func(ctx context.Context, payload data.GetOHLCRequest) ([]data.OHLCEntity, error) {
//				panic("mock out the GetDataPoints method")
//			},
//			GetProcessingStatusFunc: func(ctx context.Context, fileName string) (*data.ProcessingStatusEntity, error) {
//				panic("mock out the GetProcessingStatus method")
//			},
//			InsertDataPointsFunc: func(ctx context.Context, rows []data.OHLCEntity) error {
//				panic("mock out the InsertDataPoints method")
//			},
//			InsertProcessingStatusFunc: func(ctx context.Context, status data.ProcessingStatusEntity) error {
//				panic("mock out the InsertProcessingStatus method")
//			},
//			RemoveStaleProcessingStatusFunc: func(ctx context.Context, staleTime time.Time) error {
//				panic("mock out the RemoveStaleProcessingStatus method")
//			},
//			UpdateProcessingStatusFunc: func(ctx context.Context, status data.ProcessingStatusEntity) error {
//				panic("mock out the UpdateProcessingStatus method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// GetDataPointsFunc mocks the GetDataPoints method.
	GetDataPointsFunc func(ctx context.Context, payload data.GetOHLCRequest) ([]data.OHLCEntity, error)

	// GetProcessingStatusFunc mocks the GetProcessingStatus method.
	GetProcessingStatusFunc func(ctx context.Context, fileName string) (*data.ProcessingStatusEntity, error)

	// InsertDataPointsFunc mocks the InsertDataPoints method.
	InsertDataPointsFunc func(ctx context.Context, rows []data.OHLCEntity) error

	// InsertProcessingStatusFunc mocks the InsertProcessingStatus method.
	InsertProcessingStatusFunc func(ctx context.Context, status data.ProcessingStatusEntity) error

	// RemoveStaleProcessingStatusFunc mocks the RemoveStaleProcessingStatus method.
	RemoveStaleProcessingStatusFunc func(ctx context.Context, staleTime time.Time) error

	// UpdateProcessingStatusFunc mocks the UpdateProcessingStatus method.
	UpdateProcessingStatusFunc func(ctx context.Context, status data.ProcessingStatusEntity) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDataPoints holds details about calls to the GetDataPoints method.
		GetDataPoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Payload is the payload argument value.
			Payload data.GetOHLCRequest
		}
		// GetProcessingStatus holds details about calls to the GetProcessingStatus method.
		GetProcessingStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileName is the fileName argument value.
			FileName string
		}
		// InsertDataPoints holds details about calls to the InsertDataPoints method.
		InsertDataPoints []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Rows is the rows argument value.
			Rows []data.OHLCEntity
		}
		// InsertProcessingStatus holds details about calls to the InsertProcessingStatus method.
		InsertProcessingStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status data.ProcessingStatusEntity
		}
		// RemoveStaleProcessingStatus holds details about calls to the RemoveStaleProcessingStatus method.
		RemoveStaleProcessingStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StaleTime is the staleTime argument value.
			StaleTime time.Time
		}
		// UpdateProcessingStatus holds details about calls to the UpdateProcessingStatus method.
		UpdateProcessingStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status data.ProcessingStatusEntity
		}
	}
	lockGetDataPoints               sync.RWMutex
	lockGetProcessingStatus         sync.RWMutex
	lockInsertDataPoints            sync.RWMutex
	lockInsertProcessingStatus      sync.RWMutex
	lockRemoveStaleProcessingStatus sync.RWMutex
	lockUpdateProcessingStatus      sync.RWMutex
}

// GetDataPoints calls GetDataPointsFunc.
func (mock *RepositoryMock) GetDataPoints(ctx context.Context, payload data.GetOHLCRequest) ([]data.OHLCEntity, error) {
	if mock.GetDataPointsFunc == nil {
		panic("RepositoryMock.GetDataPointsFunc: method is nil but Repository.GetDataPoints was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Payload data.GetOHLCRequest
	}{
		Ctx:     ctx,
		Payload: payload,
	}
	mock.lockGetDataPoints.Lock()
	mock.calls.GetDataPoints = append(mock.calls.GetDataPoints, callInfo)
	mock.lockGetDataPoints.Unlock()
	return mock.GetDataPointsFunc(ctx, payload)
}

// GetDataPointsCalls gets all the calls that were made to GetDataPoints.
// Check the length with:
//
//	len(mockedRepository.GetDataPointsCalls())
func (mock *RepositoryMock) GetDataPointsCalls() []struct {
	Ctx     context.Context
	Payload data.GetOHLCRequest
} {
	var calls []struct {
		Ctx     context.Context
		Payload data.GetOHLCRequest
	}
	mock.lockGetDataPoints.RLock()
	calls = mock.calls.GetDataPoints
	mock.lockGetDataPoints.RUnlock()
	return calls
}

// GetProcessingStatus calls GetProcessingStatusFunc.
func (mock *RepositoryMock) GetProcessingStatus(ctx context.Context, fileName string) (*data.ProcessingStatusEntity, error) {
	if mock.GetProcessingStatusFunc == nil {
		panic("RepositoryMock.GetProcessingStatusFunc: method is nil but Repository.GetProcessingStatus was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		FileName string
	}{
		Ctx:      ctx,
		FileName: fileName,
	}
	mock.lockGetProcessingStatus.Lock()
	mock.calls.GetProcessingStatus = append(mock.calls.GetProcessingStatus, callInfo)
	mock.lockGetProcessingStatus.Unlock()
	return mock.GetProcessingStatusFunc(ctx, fileName)
}

// GetProcessingStatusCalls gets all the calls that were made to GetProcessingStatus.
// Check the length with:
//
//	len(mockedRepository.GetProcessingStatusCalls())
func (mock *RepositoryMock) GetProcessingStatusCalls() []struct {
	Ctx      context.Context
	FileName string
} {
	var calls []struct {
		Ctx      context.Context
		FileName string
	}
	mock.lockGetProcessingStatus.RLock()
	calls = mock.calls.GetProcessingStatus
	mock.lockGetProcessingStatus.RUnlock()
	return calls
}

// InsertDataPoints calls InsertDataPointsFunc.
func (mock *RepositoryMock) InsertDataPoints(ctx context.Context, rows []data.OHLCEntity) error {
	if mock.InsertDataPointsFunc == nil {
		panic("RepositoryMock.InsertDataPointsFunc: method is nil but Repository.InsertDataPoints was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Rows []data.OHLCEntity
	}{
		Ctx:  ctx,
		Rows: rows,
	}
	mock.lockInsertDataPoints.Lock()
	mock.calls.InsertDataPoints = append(mock.calls.InsertDataPoints, callInfo)
	mock.lockInsertDataPoints.Unlock()
	return mock.InsertDataPointsFunc(ctx, rows)
}

// InsertDataPointsCalls gets all the calls that were made to InsertDataPoints.
// Check the length with:
//
//	len(mockedRepository.InsertDataPointsCalls())
func (mock *RepositoryMock) InsertDataPointsCalls() []struct {
	Ctx  context.Context
	Rows []data.OHLCEntity
} {
	var calls []struct {
		Ctx  context.Context
		Rows []data.OHLCEntity
	}
	mock.lockInsertDataPoints.RLock()
	calls = mock.calls.InsertDataPoints
	mock.lockInsertDataPoints.RUnlock()
	return calls
}

// InsertProcessingStatus calls InsertProcessingStatusFunc.
func (mock *RepositoryMock) InsertProcessingStatus(ctx context.Context, status data.ProcessingStatusEntity) error {
	if mock.InsertProcessingStatusFunc == nil {
		panic("RepositoryMock.InsertProcessingStatusFunc: method is nil but Repository.InsertProcessingStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Status data.ProcessingStatusEntity
	}{
		Ctx:    ctx,
		Status: status,
	}
	mock.lockInsertProcessingStatus.Lock()
	mock.calls.InsertProcessingStatus = append(mock.calls.InsertProcessingStatus, callInfo)
	mock.lockInsertProcessingStatus.Unlock()
	return mock.InsertProcessingStatusFunc(ctx, status)
}

// InsertProcessingStatusCalls gets all the calls that were made to InsertProcessingStatus.
// Check the length with:
//
//	len(mockedRepository.InsertProcessingStatusCalls())
func (mock *RepositoryMock) InsertProcessingStatusCalls() []struct {
	Ctx    context.Context
	Status data.ProcessingStatusEntity
} {
	var calls []struct {
		Ctx    context.Context
		Status data.ProcessingStatusEntity
	}
	mock.lockInsertProcessingStatus.RLock()
	calls = mock.calls.InsertProcessingStatus
	mock.lockInsertProcessingStatus.RUnlock()
	return calls
}

// RemoveStaleProcessingStatus calls RemoveStaleProcessingStatusFunc.
func (mock *RepositoryMock) RemoveStaleProcessingStatus(ctx context.Context, staleTime time.Time) error {
	if mock.RemoveStaleProcessingStatusFunc == nil {
		panic("RepositoryMock.RemoveStaleProcessingStatusFunc: method is nil but Repository.RemoveStaleProcessingStatus was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		StaleTime time.Time
	}{
		Ctx:       ctx,
		StaleTime: staleTime,
	}
	mock.lockRemoveStaleProcessingStatus.Lock()
	mock.calls.RemoveStaleProcessingStatus = append(mock.calls.RemoveStaleProcessingStatus, callInfo)
	mock.lockRemoveStaleProcessingStatus.Unlock()
	return mock.RemoveStaleProcessingStatusFunc(ctx, staleTime)
}

// RemoveStaleProcessingStatusCalls gets all the calls that were made to RemoveStaleProcessingStatus.
// Check the length with:
//
//	len(mockedRepository.RemoveStaleProcessingStatusCalls())
func (mock *RepositoryMock) RemoveStaleProcessingStatusCalls() []struct {
	Ctx       context.Context
	StaleTime time.Time
} {
	var calls []struct {
		Ctx       context.Context
		StaleTime time.Time
	}
	mock.lockRemoveStaleProcessingStatus.RLock()
	calls = mock.calls.RemoveStaleProcessingStatus
	mock.lockRemoveStaleProcessingStatus.RUnlock()
	return calls
}

// UpdateProcessingStatus calls UpdateProcessingStatusFunc.
func (mock *RepositoryMock) UpdateProcessingStatus(ctx context.Context, status data.ProcessingStatusEntity) error {
	if mock.UpdateProcessingStatusFunc == nil {
		panic("RepositoryMock.UpdateProcessingStatusFunc: method is nil but Repository.UpdateProcessingStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Status data.ProcessingStatusEntity
	}{
		Ctx:    ctx,
		Status: status,
	}
	mock.lockUpdateProcessingStatus.Lock()
	mock.calls.UpdateProcessingStatus = append(mock.calls.UpdateProcessingStatus, callInfo)
	mock.lockUpdateProcessingStatus.Unlock()
	return mock.UpdateProcessingStatusFunc(ctx, status)
}

// UpdateProcessingStatusCalls gets all the calls that were made to UpdateProcessingStatus.
// Check the length with:
//
//	len(mockedRepository.UpdateProcessingStatusCalls())
func (mock *RepositoryMock) UpdateProcessingStatusCalls() []struct {
	Ctx    context.Context
	Status data.ProcessingStatusEntity
} {
	var calls []struct {
		Ctx    context.Context
		Status data.ProcessingStatusEntity
	}
	mock.lockUpdateProcessingStatus.RLock()
	calls = mock.calls.UpdateProcessingStatus
	mock.lockUpdateProcessingStatus.RUnlock()
	return calls
}
